#!/usr/bin/env ruby --enable=frozen-string-literal

$my_dir = File.dirname(File.absolute_path(__FILE__))

require 'cgi'
require 'stringio'
require 'tempfile'
require 'tmpdir'
require 'open3'
require 'zip'
require 'fileutils'

$LOAD_PATH.unshift(File.join($my_dir, "lib"))

require 'micro_macro_proc'

Zipname="images.zip"

def despace(x)
  x.is_a?(String) ? x.tr(' ', '') : x
end

def save_to(events, target)
  File.open(target, 'w') do
    |output|

    output.write(events.read)
    
  end
end

def make_decay(decay, tau)
  case decay
  when "none", "step"
    return decay

  when "lin"
    return "linear:#{despace(tau)}"

  when "exp"
    return "exp:#{despace(tau)}"

  else
    raise "I shouldn't be here"
  end

end

def create_zip_archive(dir, basename_template)
  zipfile_name = File.join(dir, "#{Zipname}");
  $stderr.puts(zipfile_name);
  
  input_filenames = Dir.glob(File.join(dir, pattern));
  return nil if input_filenames.empty?


  Zip::File.open(zipfile_name, Zip::File::CREATE) do |zipfile|
    input_filenames.each do |path|
      # Two arguments:
      # - The name of the file as it will appear in the archive
      # - The original file, including the path to find it
      zipfile.add(File.basename(path), path)
    end
  end

  return zipfile_name
end

def create_success_page(cgi, dir, basename_template)
  zip_path=create_zip_archive(dir, basename_template)

  $stderr.puts(cgi.inspect)
  
  cgi.out("type" => "application/zip",
         # "disposition" => "attachment; filename=#{File.basename(zip_path)}"
         ) {
    File.read(zip_path)
  }
end

def create_error_page(cgi, status, stderr)
  cgi.out do
    cgi.html do
      cgi.body do
        cgi.p do
          CGI::escapeHTML(
            "Command terminated with error: " + stderr
          )
        end
      end
    end
  end
end


def timestamp
  t=Time.now;

  return t.tv_sec.to_s + t.tv_usec.to_s
end

def to_link(path)
  if (path[0...$my_dir.size] == $my_dir && path[$my_dir.size]='/')
    return path[$my_dir.size+1 .. -1]
  else
    raise "Boh"
  end
end

def with_status_dir
  t = Time.now.sec
  status_dir = File.absolute_path(File.join($my_dir, "status/#{timestamp}"))

  FileUtils.mkpath(status_dir)
  
  yield(status_dir)
end

cgi=CGI.new("html4")


with_status_dir do |dir|
  # $stderr.puts(cgi.params.inspect)
  # cgi.out { 'pippo' }
  # exit
  
  frame_rate = despace(cgi.params['fps'][0])

  decay    = make_decay(cgi.params['decay'][0], cgi.params['tau'][0])

  basename_template = File.basename(cgi.params['template'][0])
  template = File.join(dir, basename_template)


  progress_file=File.join(dir, 'progress')
  stderr_file=File.join(dir, 'stderr')
  stdout_file=File.join(dir, 'stderr')
  event_file=File.join(dir, 'events.csv')

  save_to(cgi.params['myfile'][0], event_file)

  params = []
  params << stderr_file
  params << stdout_file
  params << "--sampling=#{frame_rate}"
  params << "--decay=#{decay}"
  params << "--output=#{template}"
  params << "--input=#{event_file}"
  params << "--progress=#{progress_file}"

  cgi.out do
    cgi.html do
      cgi.body do
        expanded=Array.new

        macros = { "status_dir"  => dir,
                   "zipfile"     => to_link(File.join(dir, Zipname)),
                   "status_file" => to_link(progress_file),
                   "stderr"      => to_link(stderr_file)
                 }

        Micro_Macro_Proc.expand(File.readlines(File.join($my_dir, 'working-for-you.thtml')),
                                expanded,
                                macros,
                                :on_undefined => :die)

        expanded.join('')
                                
      end
    end
  end

  $stderr.puts(params.inspect)

  system(File.join($my_dir, "../exe/intermediario.sh"), *params)

  $stderr.puts(44)
  
#  child_pid=fork
#
#  if child_pid
#    # I'm the parent.  Just exit
#    Process.detach(child_pid)
#  else
#    # I'm the child.  Do stderr redirection
#    $stdin.close
#    $stderr.close
#    $stdout.close
#    
#    $stderr=File.open(stderr_file, 'w')
#    $stdout=$stderr
#
#    exec(File.join($my_dir, "../exe/accumulator.exe"), *params)
#  end
    
#  stdout, stderr, status=Open3.capture3(File.join($my_dir, "../exe/accumulator.exe"), *params)
#
#  if status.success?
#    $stderr.puts('ok')
#    
#    create_success_page(cgi, dir, basename_template)
#
#  else
#    $stderr.puts('NO')
#    create_error_page(cgi, status, stderr)
#
#  end

end

# $stderr.puts (cgi.params.inspect)
# 
# cgi.print("Panini fritti!!!")
# cgi.print (cgi.params.inspect)
# 
# cgi.print(cgi.params['myfile'].first.read)
#   
# cgi.print(cgi.files.inspect)

# class CGIbis < CGI
#   include CGI::QueryExtension
# end
# 
# 
